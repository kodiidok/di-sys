<!DOCTYPE html>
<html>
<head>
<title>theory.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<div style="text-align: justify">
<h1 id="theory"><strong>Theory</strong></h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#theory"><strong>Theory</strong></a>
<ul>
<li><a href="#1-introduction"><strong>1. Introduction</strong></a>
<ul>
<li><a href="#11-define"><strong>1.1 Define</strong></a></li>
<li><a href="#12-why-not-ds"><strong>1.2 Why not DS?</strong></a></li>
<li><a href="#13-why-ds"><strong>1.3 Why DS?</strong></a></li>
</ul>
</li>
<li><a href="#2-concurrency-and-parallel-processing"><strong>2. Concurrency and Parallel Processing</strong></a>
<ul>
<li><a href="#21-thread-process-and-fork"><strong>2.1 Thread, Process and Fork</strong></a></li>
<li><a href="#22-channels-and-pipes"><strong>2.2 Channels and Pipes</strong></a></li>
<li><a href="#23-locks"><strong>2.3 Locks</strong></a>
<ul>
<li><a href="#231-example"><strong>2.3.1 Example</strong></a></li>
</ul>
</li>
<li><a href="#24-deadlocks-livelocks-and-starvation"><strong>2.4 Deadlocks, Livelocks and Starvation</strong></a></li>
<li><a href="#25-race-conditions"><strong>2.5 Race Conditions</strong></a></li>
<li><a href="#26-blind-writes"><strong>2.6 Blind Writes</strong></a></li>
</ul>
</li>
<li><a href="#3-communication-and-rpc"><strong>3. Communication and RPC</strong></a>
<ul>
<li><a href="#31-latency-and-bandwidth"><strong>3.1 Latency and Bandwidth</strong></a></li>
<li><a href="#32-remote-procedure-calls-rpc"><strong>3.2 Remote Procedure Calls (RPC)</strong></a>
<ul>
<li><a href="#321-example"><strong>3.2.1 Example</strong></a></li>
<li><a href="#322-invoking-rpc"><strong>3.2.2 Invoking RPC</strong></a></li>
<li><a href="#323-serialization-and-marshalling"><strong>3.2.3 Serialization and Marshalling</strong></a></li>
<li><a href="#324-protocol-buffer"><strong>3.2.4 Protocol Buffer</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-models"><strong>4. Models</strong></a>
<ul>
<li><a href="#41-two-generals-problem"><strong>4.1 Two Generals Problem</strong></a></li>
<li><a href="#42-byzantine-generals-problem"><strong>4.2 Byzantine Generals Problem</strong></a></li>
<li><a href="#43-systems-models"><strong>4.3 Systems Models</strong></a></li>
<li><a href="#44-network-behaviour"><strong>4.4 Network Behaviour</strong></a></li>
<li><a href="#45-node-behaviour"><strong>4.5 Node Behaviour</strong></a></li>
<li><a href="#46-time-behaviour"><strong>4.6 Time Behaviour</strong></a></li>
<li><a href="#47-violations-of-synchrony"><strong>4.7 Violations of Synchrony</strong></a>
<ul>
<li><a href="#471-congestion"><strong>4.7.1 Congestion</strong></a></li>
<li><a href="#472-contention"><strong>4.7.2 Contention</strong></a></li>
<li><a href="#473-stop-the-world-garbage-collection"><strong>4.7.3 Stop the World Garbage Collection</strong></a></li>
<li><a href="#474-page-fault-and-thrashing"><strong>4.7.4 Page Fault and Thrashing</strong></a></li>
<li><a href="#475-priority-inversion"><strong>4.7.5 Priority Inversion</strong></a></li>
</ul>
</li>
<li><a href="#48-availability"><strong>4.8 Availability</strong></a></li>
<li><a href="#49-faliure-detection"><strong>4.9 Faliure Detection</strong></a></li>
</ul>
</li>
<li><a href="#5-time"><strong>5. Time</strong></a>
<ul>
<li><a href="#51-time-for-distributed-systems"><strong>5.1 Time for Distributed Systems</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="page-break-after: always;"></div>
<h2 id="1-introduction"><strong>1. Introduction</strong></h2>
<h3 id="11-define"><strong>1.1 Define</strong></h3>
<pre><code>Multiple computers
Common Task
Client sees a single service
</code></pre>
<h3 id="12-why-not-ds"><strong>1.2 Why not DS?</strong></h3>
<pre><code>Fault Tolerance is Hard ( a system as a whole continues to work, even when some parts are faulty)

- Non reliable communication
- Processes might crash
- Coordinated and uncoordinated indeterministic   failures
</code></pre>
<h3 id="13-why-ds"><strong>1.3 Why DS?</strong></h3>
<pre><code>Parallel or Concurrent
Fault Tolerance
Physical Requirements
Isolation (Security)
Scalability
Resource Sharing
Price / Performance Ratio
Seamless Communication
Abstraction of Computation
</code></pre>
<h2 id="2-concurrency-and-parallel-processing"><strong>2. Concurrency and Parallel Processing</strong></h2>
<p><img src="images/theory/concurrency-parallel.png" alt="concurrency vs parallel"></p>
<table>
<thead>
<tr>
<th></th>
<th>Single Core</th>
<th>Multi Core</th>
</tr>
</thead>
<tbody>
<tr>
<td>Concurrent</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Parallel</td>
<td>❎</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h3 id="21-thread-process-and-fork"><strong>2.1 Thread, Process and Fork</strong></h3>
<pre><code>- Threads (of the same process) run in a shared memory space
- Processes run in separate memory spaces.
- Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.
- A thread is a subset of the process.
- A fork gives a copy of a process
- A fork has its own memory space (not shared)
</code></pre>
<h3 id="22-channels-and-pipes"><strong>2.2 Channels and Pipes</strong></h3>
<pre><code>- Pipes are channels that connect processes for communication.
- They have a write end for sending bytes and a read end for receiving these bytes in FIFO
- Channels act like pipes between two processes or threads.
- One process puts data into the channel, and the other process retrieves it.
- Channels can be used for communication between concurrent threads within the same process
- They are simpler to use than pipes because they don’t involve file descriptors or system calls.
- Pipes are typically unidirectional. Data flows from the write end to the read end. To achieve full duplex communication (both directions simultaneously), you’d need two pipes—one for each direction.
-  Channels can be bidirectional, allowing data to flow in both directions. Channels can handle simultaneous communication in both directions within the same channel.
</code></pre>
<p><img src="images/theory/channels and pipes.png" alt="channels and pipes"></p>
<h3 id="23-locks"><strong>2.3 Locks</strong></h3>
<pre><code>- A Lock can only give access to a single thread
- A mutually exclusive lock can give access to multiple threads
</code></pre>
<h4 id="231-example"><strong>2.3.1 Example</strong></h4>
<pre><code>Binary Lock
</code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// Binary Lock</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>

<span class="hljs-keyword">pthread_mutex_t</span> lock;

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">critical_section</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>{
    <span class="hljs-keyword">int</span> thread_id = *((<span class="hljs-keyword">int</span>*)arg);

    pthread_mutex_lock(&amp;lock); <span class="hljs-comment">// Acquire the binary lock</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread %d: Entered critical section\n"</span>, thread_id);
    <span class="hljs-comment">// Critical section code</span>
    pthread_mutex_unlock(&amp;lock); <span class="hljs-comment">// Release the binary lock</span>

    <span class="hljs-built_in">free</span>(arg);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">pthread_t</span> threads[<span class="hljs-number">5</span>];
    <span class="hljs-keyword">int</span>* thread_ids[<span class="hljs-number">5</span>];

    pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// Initialize the binary lock</span>

    <span class="hljs-comment">// Create and start 5 threads</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        thread_ids[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
        *thread_ids[i] = i;
        pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, critical_section, thread_ids[i]);
    }

    <span class="hljs-comment">// Wait for all threads to finish</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        pthread_join(threads[i], <span class="hljs-literal">NULL</span>);
    }

    pthread_mutex_destroy(&amp;lock); <span class="hljs-comment">// Destroy the binary lock</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre><code>Shared/Exclusive Lock
</code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// Shared/Exclusive Lock</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>

<span class="hljs-keyword">pthread_rwlock_t</span> rwlock;

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">read_shared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>{
    pthread_rwlock_rdlock(&amp;rwlock); <span class="hljs-comment">// Acquire a shared read lock</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread %ld: Reading shared resource\n"</span>, pthread_self());
    <span class="hljs-comment">// Read from shared resource</span>
    pthread_rwlock_unlock(&amp;rwlock); <span class="hljs-comment">// Release the shared read lock</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">write_exclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>{
    pthread_rwlock_wrlock(&amp;rwlock); <span class="hljs-comment">// Acquire an exclusive write lock</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread %ld: Writing to shared resource\n"</span>, pthread_self());
    <span class="hljs-comment">// Write to shared resource</span>
    pthread_rwlock_unlock(&amp;rwlock); <span class="hljs-comment">// Release the exclusive write lock</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">pthread_t</span> threads[<span class="hljs-number">5</span>];

    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// Initialize the shared-exclusive lock</span>

    <span class="hljs-comment">// Create threads for shared read access</span>
    pthread_create(&amp;threads[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, read_shared, <span class="hljs-literal">NULL</span>);
    pthread_create(&amp;threads[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, read_shared, <span class="hljs-literal">NULL</span>);
    pthread_create(&amp;threads[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, read_shared, <span class="hljs-literal">NULL</span>);

    <span class="hljs-comment">// Create threads for exclusive write access</span>
    pthread_create(&amp;threads[<span class="hljs-number">3</span>], <span class="hljs-literal">NULL</span>, write_exclusive, <span class="hljs-literal">NULL</span>);
    pthread_create(&amp;threads[<span class="hljs-number">4</span>], <span class="hljs-literal">NULL</span>, write_exclusive, <span class="hljs-literal">NULL</span>);

    <span class="hljs-comment">// Wait for all threads to finish</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        pthread_join(threads[i], <span class="hljs-literal">NULL</span>);
    }

    pthread_rwlock_destroy(&amp;rwlock); <span class="hljs-comment">// Destroy the shared-exclusive lock</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="24-deadlocks-livelocks-and-starvation"><strong>2.4 Deadlocks, Livelocks and Starvation</strong></h3>
<pre><code>A deadlock is a state in which each member of a group of actions, is waiting for some other member to release a lock.

A livelock is similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing.
</code></pre>
<p><img src="images/theory/deadlock.png" alt="deadlock">
<img src="images/theory/livelock.png" alt="livelock">
<img src="images/theory/starvation.png" alt="starvation"></p>
<h3 id="25-race-conditions"><strong>2.5 Race Conditions</strong></h3>
<pre><code>A race condition occurs when two or more threads can access shared data and attempt to change it simultaneously.
Can prevent using locks to ensure only one thread accesses the shared data at a time.
e.g.: Lower value than Expected (MapReduce)
</code></pre>
<h3 id="26-blind-writes"><strong>2.6 Blind Writes</strong></h3>
<pre><code>Blind writes occur when threads write to shared memory without proper synchronization.
Threads may overwrite each other’s changes, leading to incorrect results.
The final value of shared variable depends on which thread executes last.
Can prevent using properly syncing all threads.
e.g.: Higher value than Expected (MapReduce)
</code></pre>
<h2 id="3-communication-and-rpc"><strong>3. Communication and RPC</strong></h2>
<h3 id="31-latency-and-bandwidth"><strong>3.1 Latency and Bandwidth</strong></h3>
<pre><code>- Latency: Time until message arrives
- Bandwidth: Data volume per unit time 
</code></pre>
<h3 id="32-remote-procedure-calls-rpc"><strong>3.2 Remote Procedure Calls (RPC)</strong></h3>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Name</th>
<th>Protocols</th>
</tr>
</thead>
<tbody>
<tr>
<td>Layer 7</td>
<td>Application</td>
<td>SMTP, HTTP, FTP, POP3, SNMP</td>
</tr>
<tr>
<td>Layer 6</td>
<td>Presentation</td>
<td>MPEG, ASCH, SSL, TLS</td>
</tr>
<tr>
<td>Layer 5</td>
<td>Session</td>
<td>NetBIOS, SAP</td>
</tr>
<tr>
<td>Layer 4</td>
<td>Transport</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>Layer 3</td>
<td>Network</td>
<td>IPV5, IPV6, ICMP, IPSEC, ARP, MPLS.</td>
</tr>
<tr>
<td>Layer 2</td>
<td>Data Link</td>
<td>RAPA, PPP, Frame Relay, ATM, Fiber Cable, etc.</td>
</tr>
<tr>
<td>Layer 1</td>
<td>Physical</td>
<td>RS232, 100BaseTX, ISDN, 11.</td>
</tr>
</tbody>
</table>
<pre><code>A communication protocol that enables a program to execute a subroutine or procedure on a remote system over a network.
</code></pre>
<h4 id="321-example"><strong>3.2.1 Example</strong></h4>
<pre><code>In this example, we have a Calculator type that represents a calculator instance. It has a single method Add that takes two integers and returns their sum.

In the main function, we create a new instance of Calculator, register it with the RPC server using rpc.Register(calculator), and start the RPC server on port 8000.
</code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// server.go</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"net"</span>
	<span class="hljs-string">"net/rpc"</span>
)

<span class="hljs-keyword">type</span> Calculator <span class="hljs-keyword">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Calculator)</span> <span class="hljs-title">Add</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(*c) + x + y, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	calculator := <span class="hljs-built_in">new</span>(Calculator)
	rpc.Register(calculator)

	listener, err := net.Listen(<span class="hljs-string">"tcp"</span>, <span class="hljs-string">":8000"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"Failed to listen:"</span>, err)
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-keyword">defer</span> listener.Close()

	fmt.Println(<span class="hljs-string">"Listening on port 8000..."</span>)
	rpc.Accept(listener)
}
</div></code></pre>
<pre><code>In the client code, we create a new client connection to the RPC server using rpc.Dial(&quot;tcp&quot;, &quot;localhost:8000&quot;).

We then call the Add method on the remote server using client.Call(&quot;Calculator.Add&quot;, []int{3, 5}, &amp;result). The first argument is the name of the remote method, the second argument is the input arguments (an array of integers in this case), and the third argument is a pointer to a variable where the result will be stored.
</code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"net/rpc"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	client, err := rpc.Dial(<span class="hljs-string">"tcp"</span>, <span class="hljs-string">"localhost:8000"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"Failed to connect:"</span>, err)
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-keyword">defer</span> client.Close()

	<span class="hljs-keyword">var</span> result <span class="hljs-keyword">int</span>
	err = client.Call(<span class="hljs-string">"Calculator.Add"</span>, []<span class="hljs-keyword">int</span>{<span class="hljs-number">3</span>, <span class="hljs-number">5</span>}, &amp;result)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"Failed to call Add:"</span>, err)
	} <span class="hljs-keyword">else</span> {
		fmt.Printf(<span class="hljs-string">"3 + 5 = %d\n"</span>, result)
	}
}
</div></code></pre>
<pre><code>Output
</code></pre>
<pre class="hljs"><code><div>(Server terminal)
Listening on port 8000...

(Client terminal)
3 + 5 = 8
</div></code></pre>
<h4 id="322-invoking-rpc"><strong>3.2.2 Invoking RPC</strong></h4>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TCP (Transmission Control Protocol)</strong></td>
<td>reliable, connection-oriented, guarantees the delivery of data packets in the correct order, provides error-checking mechanisms.</td>
</tr>
<tr>
<td><strong>HTTP (Hypertext Transfer Protocol)</strong></td>
<td>widely used protocol, useful when the client and server are separated by firewalls or proxy servers, often used in web services and RESTful APIs.</td>
</tr>
<tr>
<td><strong>gRPC (Google Remote Procedure Call)</strong></td>
<td>high-performance, uses HTTP/2, multiplexing, header compression, bidirectional streaming. efficient, scalable, and language-agnostic.</td>
</tr>
<tr>
<td><strong>WebSocket</strong></td>
<td>persistent, bidirectional communication channel between a client and a server over a single TCP connection, allowing real-time data exchange without the overhead of traditional HTTP requests.</td>
</tr>
</tbody>
</table>
<h4 id="323-serialization-and-marshalling"><strong>3.2.3 Serialization and Marshalling</strong></h4>
<p><img src="images/theory/serialiation and marshalling.png" alt="serialiation and marshalling">
<img src="images/theory/marshalling.png" alt="marshalling"></p>
<pre><code>Serialization is persisting an object into a state independent of its execution environment. During serialization, the data is saved (in memory or physically) in a raw format, such as byte arrays or binary data. Deserialization is the reconstruction of the original object from the serialized data.

Marshaling is moving an object or method call into another execution part. It is more about the interoperability of objects between programs or threads. It can also involve serialization during its operation. Therefore, serialization is usually part of marshaling.
</code></pre>
<p><img src="images/theory/serialization vs marshalling.png" alt="serialization vs marshalling">
<img src="image.png" alt="rpc example flow"></p>
<h4 id="324-protocol-buffer"><strong>3.2.4 Protocol Buffer</strong></h4>
<pre class="hljs"><code><div>message PaymentRequest{
	message Card{
		required string cardNumber 	=    1; 
		optional int32 expiryMonth 	=    2;
		optional int32 expiryYear 	=    3;
		optional int32 CVC		=    4;
	}
}

message PaymentStatus{
	required bool success 		=   1;
	optional string errorMessage		=   2;
}
service PaymentService{
	rpc ProcessPayment(PaymentRequest) <span class="hljs-built_in">return</span> (PaymentStatus) {}
}
</div></code></pre>
<h2 id="4-models"><strong>4. Models</strong></h2>
<h3 id="41-two-generals-problem"><strong>4.1 Two Generals Problem</strong></h3>
<p><img src="images/theory/two generals problem.png" alt="two generals problem">
<img src="images/theory/two generals problem example.png" alt="two generals problem example"></p>
<p>TCP is reliable, but doesn't solve two generals problem.</p>
<p><img src="images/theory/tcp 4 way handshake.png" alt="tcp 4 way handshake">
<img src="images/theory/keep sending many messages until ack.png" alt="keep sending many messages until ack">
<img src="images/theory/keep sending periodic messages until ack.png" alt="keep sending periodic messages until ack"></p>
<h3 id="42-byzantine-generals-problem"><strong>4.2 Byzantine Generals Problem</strong></h3>
<p><img src="images/theory/byzantine generals problem.png" alt="byzantine generals problem"></p>
<pre><code>- Up to f generals might behave maliciously
- Honest generals don’t know who the malicious ones are
- The malicious generals may collude
- Nevertheless, honest generals must agree on plan

need 3f+1 generals in total to tolerate f malicious generals (&lt;1/3 may be malicious)
</code></pre>
<h3 id="43-systems-models"><strong>4.3 Systems Models</strong></h3>
<pre><code>- Network behavior ( messages may be loss)
- Node behavior (crashes / faults ) 
- Time behavior  (latency)
</code></pre>
<h3 id="44-network-behaviour"><strong>4.4 Network Behaviour</strong></h3>
<pre><code>- Reliable (perfect) links: Message is received if and only id it is sent 
- Fair-loss links: Message may or be lost, duplicated, or reordered. if kept retrying message eventually gets through 
- Arbitrary links: A malicious adversity may interfere with messages (eavesdrop, modify, drop, spoof, reply)

- Network partitioning : some links dropping/ delaying all messages for extended period of time 
</code></pre>
<h3 id="45-node-behaviour"><strong>4.5 Node Behaviour</strong></h3>
<pre><code>- Crash-Stop: A node is faulty if it crashes (at any time). After crashing, it stops execution (forever)
- Crash-Recovery: A node may crash at any moment, losing its in-memory (volatite) 	state. It may resume executing sometime later 
- Byzantine (fail-arbitrary): A node is faulty if it deviates from the algorithm, Faulty nodes may do anything, including crashing or malicious
</code></pre>
<h3 id="46-time-behaviour"><strong>4.6 Time Behaviour</strong></h3>
<pre><code>- Synchronous: Message latency no greater than a known upper bound. Nodes execute algorithm at a known speed
- Partially synchronous: System is asynchronous for some finite ( but, unknown) period of 	time, Synchronous otherwise
- Asynchronous: Messages can be delayed arbitrarily. Nodes can pause execution arbitrarily. No timing guaranties 
</code></pre>
<h3 id="47-violations-of-synchrony"><strong>4.7 Violations of Synchrony</strong></h3>
<pre><code>Networks
  - predictive latency
  - Message loss requiring retry 
  - Congestion/ contention causing queueing 
  - Network/route reconfiguration 

Nodes
  - predictable speed
  - Operating system scheduling issues (priority inversion)
  - Stop-the-world garbed collection pause 
  - Page fault (trashing)
</code></pre>
<h4 id="471-congestion"><strong>4.7.1 Congestion</strong></h4>
<pre><code>- Congestion occurs when there is too much traffic on the network, and the available resources (like bandwidth or buffers) are not enough to handle it.
- It causes delays, packet loss, and reduced throughput (data transfer rate).
- Congestion can happen due to high traffic volumes, sudden traffic bursts, inefficient routing, or network failures.
</code></pre>
<h4 id="472-contention"><strong>4.7.2 Contention</strong></h4>
<pre><code>- Contention happens when multiple devices or processes try to access or use the same shared resource at the same time.
- It leads to increased latency (delay) because entities have to wait for the resource to become available.
- Contention can also reduce overall throughput and cause unfairness, where some entities get more access than others.
</code></pre>
<h4 id="473-stop-the-world-garbage-collection"><strong>4.7.3 Stop the World Garbage Collection</strong></h4>
<pre><code>In programming, garbage collection is the process of automatically reclaiming memory occupied by objects or data structures that are no longer in use by the program. This helps prevent memory leaks and simplifies memory management for developers.

The &quot;Stop-the-world&quot; part of the phrase refers to the fact that, in some garbage collection implementations, the entire application or program execution is temporarily suspended or paused while the garbage collection process is happening. This means that all running threads or processes are stopped, and no code is executing during this period.
</code></pre>
<h4 id="474-page-fault-and-thrashing"><strong>4.7.4 Page Fault and Thrashing</strong></h4>
<pre><code>A page fault is an exception or interrupt that occurs when a program tries to access a memory page that is not currently in the computer's physical memory (RAM). When this happens, the operating system needs to bring the required page from disk into memory before the program can continue executing.

Thrashing is a situation that occurs when a computer spends most of its time handling page faults, instead of executing productive instructions. This happens when the system's physical memory is too small to hold the working set of active memory pages required by the running programs.
</code></pre>
<h4 id="475-priority-inversion"><strong>4.7.5 Priority Inversion</strong></h4>
<pre><code>A scheduling problem that causes a high-priority task to be blocked or delayed by a lower-priority task.

In operating systems, priority inversion can happen due to various reasons, such as:

- Sharing of resources: If a low-priority task holds a resource (like a lock or a semaphore) that a high-priority task needs, the high-priority task may get blocked until the low-priority task releases the resource.
- Interrupts: If a low-priority task is interrupted by a higher-priority task, but then the higher-priority task gets blocked (e.g., waiting for I/O), the low-priority task may continue executing, delaying the higher-priority task.
- Scheduling algorithms: Some scheduling algorithms can cause priority inversion due to their design or implementation.
</code></pre>
<h3 id="48-availability"><strong>4.8 Availability</strong></h3>
<pre><code>Availability – Uptime -&gt; fraction of time that a service is functioning correctly

Two nines -&gt; 99%	(down 3.7 days /year)
Three nines -&gt; 99.9%	(down 8.8 hours /year)
Four nines -&gt; 99.99%	(down 53 minutes /year)
Five nines -&gt; 99.999%	(down 5.3 minutes /year)
</code></pre>
<h3 id="49-faliure-detection"><strong>4.9 Faliure Detection</strong></h3>
<pre><code>For crash stop/ crash recovery : send message, wait response, label node as crashed if no reply within some timeout

Cannot tell the difference between crashed node, temporarily unresponsive node, lost messages, and delayed messages.

Perfect timeout-based failure detectors exists only in a synchronous crash-stop system with reliable links. 

Eventually perfect failure detector 
- May temporarily label a node as crashed even though it is correct
- May temporarily label a node as correct, even though it has crashed
- But, eventually, label a node as crashed if and only if it has crashed  
</code></pre>
<h2 id="5-time"><strong>5. Time</strong></h2>
<pre><code>For software systems:

    Time is represented as numerical values, like timestamps or durations.
    Software uses time for scheduling tasks, tracking events, and measuring performance.
    Time is typically obtained from hardware clocks or external time sources.

For Operating Systems:

    Operating systems use time for scheduling processes and managing resources.
    They have a system clock and timers to keep track of time.
    Time is important for fair resource allocation and maintaining system stability.

For Distributed Systems:

    In distributed systems, there is no single global notion of time across different machines.
    They use techniques like logical clocks or time synchronization protocols to establish a consistent view of time.
    Consistent time is crucial for coordinating operations and ensuring data consistency across different nodes.
</code></pre>
<h3 id="51-time-for-distributed-systems"><strong>5.1 Time for Distributed Systems</strong></h3>
<pre><code>- Scheduler  (also in operating systems) : For Scheduling, Timeouts, Failure Detectors, Retry time , etc..
- Performance measurement statistics, profiling : Time a process had been running, CPU usage, etc
- Log files &amp; databases : Records when an event occurs
- Date with timelimited validity : cache entries   DNS / TLS / etc 
</code></pre>
<p><img src="images/theory/types of clocks.png" alt="types of clocks"></p>
</div>
</body>
</html>
